<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>次时代Java编程(二) vertx-lang-kotlin-coroutines介绍 | Writing for Thingking</title><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">次时代Java编程(二) vertx-lang-kotlin-coroutines介绍</h1><a id="logo" href="/.">Writing for Thingking</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">次时代Java编程(二) vertx-lang-kotlin-coroutines介绍</h1><div class="post-meta">Sep 29, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>上一篇文章，也就是去年(我真懒)写了一遍关于JVM上的协程文章。当时是基于Quasar来实现Java的协程，虽然能达到类似Golang的效果，当时需要在运行时加载一个修改字节码的Jar，用起来不是很舒服，毕竟Java出来的时候协程这个概念还没火，所以需要一些方法hack一下。  </p>
<p>今年Google钦定了一个Andriod上的语言<code>Kotlin</code>，一下子把这个JVM新生的语言捧火了，这个语言亲爹是Jetbrain，干爹现在又是Google，真的是火的不行，当然目前也是在Andriod那边火，毕竟他们一直用的是阉割版的Java8。  </p>
<h3 id="JVM上的又一个新秀kotlin"><a href="#JVM上的又一个新秀kotlin" class="headerlink" title="JVM上的又一个新秀kotlin"></a>JVM上的又一个新秀kotlin</h3><p>Kotlin今年在Google大会上已经被捧起来了，各方面的资料犹如汗牛充栋，大家可以随便搜索到，我这里就简单的介绍一下他的优势。</p>
<ul>
<li>简约，支持局部变量类型推导，有完善的data class，函数扩展，智能转换(省代码)，类委托，等等</li>
<li>安全，比如空引用判断，NPE异常在Java里很常见，Kotlin可以通过在类型后面加<code>?</code>让程序在编译期间进行检查。</li>
<li>通用，koltin除了可以跑在JVM上，也可以编译成javascript代码跑在node上。</li>
<li>无缝兼容Java，Jetbrains的目标是让他们100%兼容(可以互相调用)，这点比太阳系最骚语言<code>Scala</code>要强。  </li>
</ul>
<p>另外还有两点能体现出kotlin会比scala更流行的地方。  </p>
<ul>
<li>IDE支持力度，亲爹就是做IDE出身的，可以看到kotlin-plugin更新速度是kotlin编译器以及语言是一样快的。  </li>
<li>kotlin直接编译成Java字节码，所以编译速度上也会比Scala要快一点  </li>
</ul>
<p>本篇文章并不打算详细介绍这门语言，有兴趣的可以自己去官网看一下文档，有Java8基础的同学估计1天就能入门，有Scala基础的同学更好入门了，别想太多就好。  </p>
<h3 id="kotlin的coroutines"><a href="#kotlin的coroutines" class="headerlink" title="kotlin的coroutines"></a>kotlin的coroutines</h3><p>上面说了一堆kotlin的优势，但是最大的优势是有牛人为他设计并实现了coroutines，为此kotlin引入了<code>suspend</code>关键字，作用在函数或者lambda上。<br>上两篇文章已经介绍了协程的概念以及大致的原理，这里就不啰嗦了，简单的介绍kotlin-coroutines概念后，直接上例子。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    launch(CommonPool) &#123; </span><br><span class="line">        delay(<span class="number">1000</span>L) <span class="comment">// 延迟1S</span></span><br><span class="line">        println(<span class="string">"World!"</span>) <span class="comment">// 打印World</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// 在launch块外面则是Main线程</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>L) <span class="comment">// 主线程休眠2S</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码最终会输出<code>Hello, World</code>。大家可能对上面的一些方法与函数不太了解，我这里简单说一下。<br><code>launch(CommonPool){}</code>中的launch其实是一个<code>Builder</code>方法，用他来构建一个跑coroutines的环境，同时接受一个参数，这个参数用来表示协程将跑在哪些线程里，<code>CommonPool</code>默认建议用Java7的<code>forkJoinPool</code>，这个线程池是特别优化过的支持<code>work-stealing</code>算法，与Golang的协程调度器很像，(当然还是有点不一样的)，<code>forkJoinPool</code>默认数目是CPU * 2，这样可以最大限度使用CPU资源。<br>好了现在我们通过<code>launch</code>这个Builder方法以及<code>CommonPool</code>这个参数构造了一个可以跑协程的代码块，这里注意，所有协程的逻辑只能跑在<code>launch {}</code>块里，超出这个范围就是主线程了。<br>下面在这个代码块里我们执行了协程库提供的方法<code>delay</code>，这里的delay只停止某一个协程，而不是整个线程。所以外面的<code>Thread.sleep</code>不会阻塞到<code>CommonPool</code>里的协程，所以你会在1秒后看到<code>World!</code>  </p>
<p>下面我们再看一个例子.  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array&lt;String&gt;</span>)</span> = runBlocking<span class="type">&lt;Unit&gt;</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> time</span> = measureTimeMillis &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> one</span> = async(CommonPool) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> two</span> = async(CommonPool) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(<span class="string">"The answer is $&#123;one.await() + two.await()&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in $time ms"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span>: <span class="keyword">Int</span> &#123;</span></span><br><span class="line">    delay(<span class="number">1000</span>L)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span>: <span class="keyword">Int</span> &#123;</span></span><br><span class="line">    delay(<span class="number">1000</span>L)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又多了一个新的coroutines环境Builder方法<code>async</code>，通过async方法调用一个标注<code>suspend</code>的fun可以得到一个返回值奥。<br>这里<code>suspend</code>的方法其实是告诉koltin编译器，我这里是一个可以中断的方法，用于coroutines环境，这样所有的其他的coroutines方法都可以用在这个函数内部比如<code>delay()</code>。现在我们回到<code>async</code>方法的返回值<code>val one</code>，这个里kotlin已经做了类型推断，所以我们没有定义类型，查看<code>async</code>方法的返回类型你会发现这里的<code>one</code>类型应该是<code>Deferred</code>，再具体一点应该是<code>val one:Deferred&lt;Int&gt;</code>。有点像<code>Future&lt;Integer&gt;</code>，但是注意一下<code>println</code>方法里的方法，我们这里可以直接的以同步的方式获取结果<code>one.await()</code>，而Future则需要再包一个回调，稍显麻烦。<br><code>await()</code>方法被调用时会阻塞一个协程，并对其求值，如果没有发生异常则将其结果同步返回到引用的变量上，这就是coroutines的魅力，你可以以同步的方式来完成异步的逻辑，同时避免了回调地域，且逻辑非常符合人类的认知。<br>koltin的coroutines还提供了<code>Channel</code>，<code>Mutex</code>， 和<code>Select</code>这些非常眼熟吧，具体由于篇幅关系我就不提了，大家有兴趣看官方文档，我这边只是抛个砖而已。</p>
<h3 id="当koltin-coroutines遇到vert-x"><a href="#当koltin-coroutines遇到vert-x" class="headerlink" title="当koltin-coroutines遇到vert.x"></a>当koltin-coroutines遇到vert.x</h3><p>kotlin-coroutines单独使用，没有任何问题，一般用在一些提供异步API的地方比如Java8的CompletableFuture，AIO等，也可以和Reactive库配合使用，官方默认提供了一些适配Rx1，Rx2，UI层面上也提供了一些适配比如Andriod，JavaFx等。coroutines本质上就是异步回调的代替者。<br>那JVM的全异步库vert.x岂不是和kotlin-coroutines是绝配，因为之前倒腾过<code>vertx-sync</code>，所以决定尝试一下用kotlin-coroutines包装vert.x的handler。因为kotlin-cortouines的封装以及API非常优雅，几乎没有多少行代码(两百多行有效代码)，就把项目跑起来了，后来又经过社区各方面的牛人修修补补，以及语义上的规范，API的完善，已经进了vert.x官方的<a href="https://github.com/vert-x3/vertx-lang-kotlin/tree/master/vertx-lang-kotlin-coroutines" target="_blank" rel="external">仓库</a>，会与vert.x-3.5会一起发布。<br>下面给出几个例子，各位就知道<code>vertx-lang-kotlin-coroutines</code>有多优雅了，下面假设各位都熟悉vert.x了。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准vert.x timerAPI写法</span></span><br><span class="line">vertx.setTimer(<span class="number">1000</span>, tid -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">"Event fired from timer"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用coroutines</span></span><br><span class="line">  launch(vertx.dispatcher()) &#123;</span><br><span class="line">    awaitEvent<span class="type">&lt;Long&gt;</span> &#123; handler -&gt;</span><br><span class="line">      vertx.setTimer(<span class="number">1000</span>, handler)</span><br><span class="line">	&#125;</span><br><span class="line">    println(<span class="string">"Event fired from timer"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>标准的vert.x timerAPI是异步的，且逻辑也是写在回调Handler里的，所以代码看起来会是嵌套的，但是上面的coroutines例子你会发现没有这个问题，所有的逻辑都是在变量timerId后面，也就是说逻辑是线性的，直觉符合人类的思考方式，你会觉得上面的会阻塞1秒下面才会执行。  </p>
<p>这里的<code>launch</code>接受的参数与标准的coroutines不一样，<code>vertx.dispatcher()</code>内部会返回一个包含vertx<code>context</code>的<code>ScheduledExecutorService</code>对象，随即在<code>launch</code>块里的代码都会跑在这个vertx的<code>context</code>下，从而保证了所有的协程都跑在vertx的<code>EventLoop</code>下，熟悉vert.x朋友应该知道vertx的context是在verticle启动的时候就已经分配给指定的EventLoop了，所以保证了所有的Handler都会安顺序跑在一个线程里面。<br>但是只把协程跑在vert.x的EventLoop里是不够的，我们还需要想办法把vert.x的回调型API改成同步的，所以这里你会看到一个新的方法<code>awaitEvent&lt;Long&gt;</code>，通过这个方法可以handler以协程的方式进行处理，从而可以直接得到一个返回值，使之变成同步返回，有兴趣的朋友可以看一下这个方法的源码，里面调用了<code>kotlin-coroutines</code>的API<code>suspendCancellableCoroutine</code>，是通过<code>suspend</code>进行修饰的。  </p>
<p>如果各位kotlin用的也比较熟悉，上面的例子还可以更简单，直接变成一行。<code>awaitEvent&lt;Long&gt;{vertx.setTimer(1000, it)}</code>  </p>
<p>OK，通过改变launch的参数，使coroutines可以跑在EventLoop下，通过包装vert.x的API使之可以通过协程同步返回。完成这两个功能vert.x就可以完美的和协程融合了。下面我们再看一个稍微复杂的例子  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> consumer</span> = vertx.eventBus().localConsumer<span class="type">&lt;String&gt;</span>(<span class="string">"a.b.c"</span>)</span><br><span class="line">consumer.handler &#123; message -&gt;</span><br><span class="line">  println(<span class="string">"Consumer received: $&#123;message.body()&#125;"</span>)</span><br><span class="line">  message.reply(<span class="string">"pong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send a message and wait for a reply</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> reply</span> = awaitResult<span class="type">&lt;Message&lt;String&gt;</span>&gt; &#123; h -&gt;</span><br><span class="line">  vertx.eventBus().send(<span class="string">"a.b.c"</span>, <span class="string">"ping"</span>, h)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"Reply received: $&#123;reply.body()&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子用了vert.x的经典的消息总线例子ping-pong。<br>我们先注册了一个consumer，总线地址是<code>a.b.c</code>，同时给了handler用于监听总线上的消息，如果收到消息则立刻给个返回<code>pong</code>。接着，通过vert.x发送了一个<code>ping</code>消息到这个总线上，同时也注册了一个handler用于接收回答消息，也就是consumer里的hander会reply过来的<code>pong</code>。这里你会注意到我们用了<code>awaitResult</code>这个API包装了<code>send</code>的最后一个参数，这样send方法里的Handler参数可以同步的返回给<code>reply</code>，也就是说通过协程变成了同步。然后我们就可以直接打印出reply里的一些数据，整体逻辑也是线性的。<br>细心的朋友会发现，这里是通过awaitResult而不是awaitEvent。这两者的区别很简单，<code>awaitResutl</code>会有一个确定的返回值，<code>awaitEvent</code>一般没有确定的返回值，有也是<code>void</code>类型。这两个方法包装了vert.x的两个核心API，<code>Handler&lt;Void&gt;</code>与<code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>，这样一说我觉得大家应该能够理解了。<br>上面只是接受一个消息，实践中可能不会这么用，另外kotlin-coroutines还提供了<code>Channel</code>类似于golang的channel，我们可以把消息总线以channel<code>stream</code>的方式来表达。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> adapter</span> = vertx.receiveChannelHandler<span class="type">&lt;Message&lt;Int&gt;</span>&gt;()</span><br><span class="line">vertx.eventBus().localConsumer<span class="type">&lt;Int&gt;</span>(<span class="string">"a.b.c"</span>).handler(adapter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 15 messages</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.15</span>) vertx.eventBus().send(<span class="string">"a.b.c"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive the first 10 messages</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> message</span> = adapter.receive()</span><br><span class="line">  println(<span class="string">"Received: $&#123;message.body()&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>vertx.receiveChannelHandler</code>是kotlin的方法扩展，也就是说直接附加到Vertx这个类里的，且不需要继承或者重写Vertx接口。不得不说这样的扩展也方便也很优雅。这个方法也很简单，就是把Vertx的<code>ReadStrem</code>接口通过kotlin-cortouines的<code>ReceiveChannel</code>包装了一下，使之变成同步。<br>然后我们将这个<code>adapter</code>变量以handler的参数传给<code>consumer</code>就可以了。跳过send方法不看，我们看到通过<code>adapter</code>的<code>receive()</code>方法，我们可以把消息流看成一个迭代器，直接遍历即可，是不是很符合我们之前的代码风格跟习惯呢。<br>这里我们一次只遍历10个，实践中我们可以再加一个定时器，定时从消息流里取数据，或者直接while(true)，这个取决于具体项目与你的用法。<br>coroutines，还提供了包装Rx以及FutureAPI的功能，vert.x里默认有自己的Future实现，我们也提供了相应的转换，而且非常简单。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> httpServerFuture</span> = Future.future<span class="type">&lt;HttpServer&gt;</span>()</span><br><span class="line">vertx.createHttpServer()</span><br><span class="line">    .requestHandler &#123; req -&gt; req.response().end(<span class="string">"Hello!"</span>) &#125;</span><br><span class="line">    .listen(<span class="number">8000</span>, httpServerFuture)</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> httpServer</span> = httpServerFuture.await()</span><br><span class="line">println(<span class="string">"HTTP server port: $&#123;httpServer.actualPort()&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">val</span> result</span> = CompositeFuture.all(httpServerFuture, httpServerFuture).await()</span><br><span class="line"><span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">    println(<span class="string">"The server is now running!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result.cause().printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子其实只有一个重点，就是<code>httpServerFuture.await()</code>。前面的代码我们很熟悉，定义了一个Future，然后接收随后的Future值，通过<code>setHandler()</code>方法，但这样也是需要传一个回调handler的。这里通过扩展<code>Future</code>的方法<code>Future.await</code>直接将结果以同步的方式返回出来，瞬间变得简单多了。同理一样可以用于<code>CompositeFuture</code>的结果处理。  </p>
<p>另外大家可能对异常捕获，以及超时处理的方式可能感兴趣，这里再贴一个例子，以解大家之惑。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">launch(vertx.dispatcher()) &#123;</span><br><span class="line">	<span class="variable"><span class="keyword">val</span> async</span> = testContext.async()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		withTimeout(<span class="number">250</span>) &#123;</span><br><span class="line">          awaitEvent<span class="type">&lt;Long&gt;</span> &#123; h -&gt; vertx.setTimer(<span class="number">500</span>, h) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Assert.fail()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: CancellationException) &#123;</span><br><span class="line">		testContext.assertTrue(Context.isOnEventLoopThread())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>withTimeout(250)</code>是kotlin-croutines提供的方法，vert.x可以无缝兼容，另外因为是同步的书写方式，大家可以直接用try catch去捕获异常，上面的例子就是通过超时机制，产生了一个异常，然后同步的捕获，这与同步的书写方式一样，而且也只发生在vert.x的<code>eventLoop</code>线程里面。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>这篇主要介绍了Kotlin，以及他的衍生项目coroutines，然后重点讲了vert.x与kotlin-coroutines的结合，而且这个项目也是得到官方支持的，并且也有kotlin-coroutines作者指点加持，所以项目还是比较可靠的。kotlin-coroutines这个项目本身的野心也是很大的，从他对第三方库兼容性来看，目标JVM平台的所有的异步库都想包装一下。从最新的kotlin-coroutines发布来看，还带了actor模型实现以及自己的asynchronousIO库，而且还为了支持Java9做了模块化。所以虽然官方一直说这个库处于experiment，但是作者也在一次演讲中表示完全可以用于生产环境，因为外部API已经稳定，不稳定的是内部API，而这个内部API一般不会对直接用户有影响。所以vert.x可以无缝的升级kotlin-coroutines，且不需要改变API。vertx-lang-kotlin-coroutines项目的测试也很完善，且测试本身也包含了很多使用方法。另外官方也提供很多<a href="https://github.com/vert-x3/vertx-lang-kotlin/blob/master/vertx-lang-kotlin-coroutines/src/main/kotlin/example/Example.kt" target="_blank" rel="external">例子</a>。我上面大部分例子也是引用这里。  </p>
</div><a data-url="http://www.streamis.me/2017/09/29/java-next-generation-2/" data-id="cj8v0fz7f000piv456pvmovqr" class="article-share-link">Aktie</a><div class="tags"><a href="/tags/vert-x/">vert.x</a></div><div class="post-nav"><a href="/2017/06/01/raft/" class="next">raft理解</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.streamis.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Emacs/">Emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Storm/">Storm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vert-x/">Vert.x</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vert-x/Asynchronize-programming/">Asynchronize programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vert-x/micro-service/">micro-service</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/vert-x源码分析/">vert.x源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/vert-x/" style="font-size: 15px;">vert.x</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/java-next-generation-2/">次时代Java编程(二) vertx-lang-kotlin-coroutines介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/raft/">raft理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/java-next-generation-1-1/">次时代Java编程(一):续 vertx-sync实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/04/java-next-generation-1/">次时代Java编程(一) Java里的协程</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/26/vertx-rpckuang-jia/">Vertx-rpc框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/06/vert-dot-x3-update/">Vert.x3 Update</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/06/vert-dot-xyu-lao-xiang-mu-jie-he/">Vert.x与老项目结合</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/04/vert-dot-xli-yi-bu-chu-li-di-san-fang-fu-wu/">Vert.x里异步处理第三方服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/02/os-x-xia-she-zhi-emacs-shellde-ls-color/">OS X 下设置Emacs Shell-mode 输出颜色</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/11/21/vert-xnei-bu-xian-cheng-fen-xi/">vert-x内部线程分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Writing for Thingking.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/share.js?v=0.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>