<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Writing for Thingking</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Writing for Thingking">
<meta property="og:url" content="http://www.streamis.me/page/3/index.html">
<meta property="og:site_name" content="Writing for Thingking">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Writing for Thingking">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Writing for Thingking" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Writing for Thingking</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.streamis.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-rang-stormfei-qi-lai" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/11/rang-stormfei-qi-lai/" class="article-date">
  <time datetime="2013-11-11T01:11:00.000Z" itemprop="datePublished">2013-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Storm/">Storm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/11/rang-stormfei-qi-lai/">让Storm飞起来</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一年前就开始关注Storm,不过当时因为其他事情一直没有机会深入了解Storm,当时也在使用ZeroMQ发现很容易造成泄漏问题,而且ZeroMQ开始出现版本<br>分裂(ZeroMQ 3系列好像是需要收费的),就没这么研究下去,精力全都去配置Emacs,学Clojure去了.<br>最近故地重游,发现Yahoo对Storm做了点贡献,传输层可插拔,添加了Netty的支持,很Nice.这里有一遍对替换后的性能测试文章.</p>
<p>目前看来对Java开发者而言,用Netty替换ZeroMQ最大的好处是,取消了对原生的库的依赖,做了真正的跨平台,测试与部署开发方便性得到了极大的提高.<br>但是,最最让人Happy的是性能提高了两倍,消息传输速度提高了两倍.使对带宽利用更加充分.</p>
<h3 id="测试">测试</h3><p>Yahoo内部已经使用Netty代替ZeroMQ作为消息传输,但是在使用之前他们自己写了一个直接让ZeroMQ达到极限的<a href="https://github.com/yahoo/storm-perf-test" target="_blank" rel="external">例子</a>.<br>这个例子充分的展现了Storm传输消息是多么的迅速.</p>
<p>这里一开始部署配置了一个非常小的拓扑,3个workers,3个bolt和3个spout,然后慢慢增长到408worker,上千个bolt和spout消息的大小也是不一样的.<br>所有的测试中消息的ACK也是启用的,每个spout允许挂起1000个消息,因此这里也有一些流控系统.Yahoo做了多次测试，每次测试的浮动大约在5%.</p>
<h3 id="结果">结果</h3><p>第一个测试是一个非常小得拓扑结果,3个worker工作在3个独立的节点上,所以这里没有资源竞争.每个worker有1个spout 1个bolt和1个acker tasker<br>从下面的图中可以看出,Netty在这种条件下性能完全高于zeroMQ,差不多高个40%-100%的消息量,这个取决于消息的大小.</p>
<p><img alt="Figure 1" src="https://lh5.googleusercontent.com/ofF2IcR8CmMac62YjMFgHP30PmmZ4QspU2BSID54fYN8lJRdrNd_0wPH6UVSPiiTcZMIL7hkdky8BaXmQRRgwdD38HR1wBATFbcnwxr-lK6XeLUWkVwTetQy"></p>
<p>貌似看起来Netty很牛叉,但是在大的拓扑结构上存在更多竞争的条件下会怎么样呢?<br>下面的图是在100worker,100spout,500bolt分布在100个spout,每个100个bolt.同时还有100个acker,基本上是之前的100倍.<br>下面图是不是看起来很奇怪,随着消息的增多,Netty的消息处理量趋向于zeroMQ.</p>
<p><img alt="Figure 2" src="https://lh5.googleusercontent.com/0ne5JXPaoRF4YbhHpB88LRXb41vbvC_mHDsP2P0AVmgfFDFWFbbmWDJP2QVSlJDlu7_nj9OErXd6H_8zPkAgyNhX7LrPk2olL-bP7sJ2O0Ac-1I5TArDuKUC"></p>
<p>为什么每秒处理能力会随着消息的大小而上升? 这完全是违反直觉的哇.仔细挖掘一下每个单独的节点.<br>图中的Worker处理曲线随着CPU使用率上升而上升,基本上CPU是800%，所有的Core都被充分利用了,但是load值平均在0.2.<br>这里很明显因为CPU忙于上下文线程切换,并没有真正的忙于处理消息.Netty是一个异步IO框架,每条消息会被回调到OS,然后线程挂起,等待被唤醒去做其他的事情.<br>一旦数据完成回调到用户进程里,一些线程就被唤醒去看看能不能处理那条消息.CPU频繁的在休眠与唤醒之间切换，浪费了大量的资源.</p>
<p>随着消息量增多,线程切换越来越少,但是很奇怪消息量还可以提升呢.这种趋势一直持续到每条消息在2.5KB左右.曲线开始在4.6G/s的消息量上下降.最后曲线与zeroMq汇集在<br>4KB大小的消息上。</p>
<p>如果真的是因为CPU切换的原因,那我们减少线程不就可以了?默认netty工作线程数目为CPU物理核数目.如果有多个Worker在一台机器上,这样Netty就会创建更多的线程.从而造成<br>频繁的CPU切换.这里有两种方法解决:</p>
<ul>
<li>每台物理机只跑一个worker.也就是说一台机器一个JVM.</li>
<li>设置线程数目为1,这样就与ZeroMQ一样了.每台物理机器一个线程.这里有一个<a href="https://github.com/nathanmarz/storm/pull/693" target="_blank" rel="external">pull request</a></li>
</ul>
<p>但是Netty默认设置并不能很好的处理大量的短消息,即使设置了每个节点一个worker.但是如果我们限制线程数目为1的时候,可以得到111%-85%的每秒消息量提升。<br>因为短小的消息JAVA处理起来非常非常的快,于是线程切换又一次影响了性能.</p>
<h1 id="结论">结论</h1><p>默认的Netty设置已经超过zeroMQ两倍的性能.而且已经用在Yahoo内部.<br>最后有相关的配置与命令,以及配置信息,这里给出贴出<a href="http://yahooeng.tumblr.com/post/64758709722/making-storm-fly-with-netty" target="_blank" rel="external">原文</a>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.streamis.me/2013/11/11/rang-stormfei-qi-lai/" data-id="cidzpu8bt000i6145srg2fl5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vert-dot-xmo-kuai-shen-ru" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/10/24/vert-dot-xmo-kuai-shen-ru/" class="article-date">
  <time datetime="2013-10-24T09:18:00.000Z" itemprop="datePublished">2013-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>►<a class="article-category-link" href="/categories/Vert-x/Asynchronize-programming/">Asynchronize programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/24/vert-dot-xmo-kuai-shen-ru/">Vert.x模块深入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近小忙了一点,一直拖着没有总结Vert.x模块其他内容,今天在下班前应该可以写完模块这一部分的总结。</p>
<h2 id="模块包含">模块包含</h2><p>有时候你会发现几个模块之间用了共同的Jar文件,或者资源文件.比如我们常用的Apache Commons Lang等.这个时候多个模块,会在JVM里加载多份,导致很多重复的引用,而且会有可能导致JVM里的方法区爆满.这个时候推荐将这些资源文件打包到一个模块里.这种模块称为资源模块.然后在其他模块里使用<code>include</code>去包含他.我们举个栗子.<br>我们有一个<code>commons-lang3.jar</code>,这个jar包希望用在两个模块下面,比如<code>com.xx.module1-v1.0</code>和<code>com.xx.module2-v1.0</code>.为了包含这个<code>commons-lang3.jar</code>我们需要创建一个模块.比如<code>com.xx.share-v1.0</code>,在这个模块的目录下建立一个<code>lib</code>文件夹,然后把<code>commons-lang3.jar</code>放到这个目录里.看起来应该是</p>
<pre><code><span class="string">|--com.xx.share-v1.0</span>
<span class="string">|----lib</span>
<span class="string">|------commons-lang3.jar</span>
</code></pre><p>最后我们在<code>com.xx.module1-v1.0 与 module2-v1.0</code>里面包含这个模块就行啦.<br><code>&quot;includes&quot;:&quot;com.xx.share-v1.0&quot;</code>,具体关于<code>mod.json</code>可以看我上一篇文章.如果你要包含多个模块,记得用逗号隔开.这里还有一点需要注意的是,被包含的模块必须是<code>非运行模块</code>.啥叫非运行模块呢.很简单就是<code>mod.json</code>里没有<code>main</code>这个声明.典型的就是语言模块.<br>模块目录结构具体的部分可以查看官网目录资料<a href="http://vertx.io/mods_manual.html#examples" target="_blank" rel="external">典型模块目录结构</a></p>
<h2 id="模块类路径与模块类加载器">模块类路径与模块类加载器</h2><p>这一块是Vert.x的比较复杂的部分,与很多修改类加载方式的框架差不多.Vert.x有自己的一套类加载管理方式.官网给的资料不一定是正确的,因为master线对类加载做了一些修改.</p>
<h3 id="模块类路径">模块类路径</h3><p>每一个模块都有自己的类加载器。这个类加载器负责加载此模块跟目录下的所有文件,包括<code>jar</code>,<code>zip</code>,<code>xml</code>,<code>properties</code>等各种格式。根路径就是模块目录.注意一点。这些被加载的文件只包含在模块的类加载器里。其他模块不能访问。</p>
<h3 id="模块类加载器">模块类加载器</h3><p>模块有自己的类路径,加载类路径下的资源的时候依赖自己类加载器.因为vert.x启动的时候会给每一个模块一个类加载器,注意这里不管你部署多个模块相同的实例,都只有对应的一个模块类加载器。<br><code>vertx runmod com.xx.module-v1.0 -instances 100</code>即是你这里声明100个实例,还是只有一个类加载器.这样也就意味着模块之间的类加载是互相隔离的.<br>同时你也不能使用静态变量在模块之间传输数据.但是这些静态变量还是可以在模块实例之间传输的.<br>另外你也可以对同一个模块设定版本号同时跑在多个Vert.x实例上.具体的场景就是模块动态替换.比如v1.0版本发现有一个Bug,这个时候你部署一个V2.0的版本.然后慢慢的等v1.0的模块不再被访问的时候,可以执行模块卸载命令卸载掉.</p>
<p>模块的加载器们是按层级分布的,一个模块加载器会含有0个或多个父类加载器.当一个模块加载资源或者文件的时候,模块加载器首先通过自己的类加载器来加载资源,如果加载不到,则会委托其父加载器去加载资源.这点恰好与标准的Java类加载机制相反.</p>
<p>如果所有父类模块都加载不到资源的话,那么Vert.x的Platform 类加载器会去搜索,Platform是Vert.x的启动者,他会在Vert.x的Home目录里去搜索.</p>
<p>一般而言直接通过命令行启动一个verticle,不会有其父模块类加载器.除非一个verticle被其一另一个模块部署,那么部署他的模块就是其父模块.这一点其实也非常好理解.被包者的都是子集.同时父加载器可以加载子集的资源.</p>
<h2 id="启动模块">启动模块</h2><h3 id="从命令行">从命令行</h3><p><code>vertx runmod org.myorg~mymod~3.2</code></p>
<p>直接跑zip包也可以<br><code>vertx runzip my-mod-3.2.zip</code></p>
<h3 id="从程序里启动">从程序里启动</h3><p>这里还是以JS作为例子</p>
<p><code>vertx.deployModule(&#39;org.myorg~mymod~3.2&#39;);</code></p>
<h2 id="如何定位模块">如何定位模块</h2><p>当尝试包含一个模块的时候,Vert.x会做以下几件事情.</p>
<ul>
<li>尝试查找<code>mods</code>目录.</li>
<li><code>VERTX_MODS</code>环境变量所指定的目录.</li>
<li><code>sys-mods</code>目录.</li>
</ul>
<p>如果以上都不存在,Vert.x 会尝试读取<code>conf</code>下的<code>repos.txt</code>文件.里面包含了一些路径.</p>
<pre><code><span class="preprocessor">#本地Maven仓库</span>
mavenLocal:~/.m2/repository

<span class="preprocessor">#Maven 公网</span>
maven:http:<span class="comment">//repo2.maven.org/maven2</span>

<span class="preprocessor"># Sonatype 仓库</span>
maven:http:<span class="comment">//oss.sonatype.org/content/repositories/snapshots</span>

<span class="preprocessor"># 一个二进制网站.你可以在这里发布二进制文件</span>
bintray:http:<span class="comment">//dl.bintray.com</span>
</code></pre><p>当然你也可以添加自己公司的私服地址,这样就可以在局域网内分享了.</p>
<p>Vert.x模块有自己的文件格式定义,这与NodeJS的package.json一样.</p>
<pre><code><span class="attribute">GroupID</span>: <span class="string">com.mycompany</span>
<span class="attribute">ArtifactID</span>: <span class="string">my-mod</span>
<span class="attribute">Version</span>: <span class="string">1.2-beta</span>
</code></pre><p>上面的定义与Maven很像,它会生成一个Vert.x模块文件名:<code>com.mycompany~my-mod~1.2-beta</code>.这就是Vert.x模块唯一字符串.如果你想从公网上直接下载zip模块.你可以尝试使用<code>dl.bintray.com</code>.</p>
<h2 id="其他命令">其他命令</h2><p>另外还两个不怎么常用的vert.x模块命令</p>
<ul>
<li>vertx pulldeps <module_name> 拉下该模块所有的相关依赖</module_name></li>
<li>vertx install <module_name> 在Vert.x容器启动前,先下载并安装该模块到<code>mods</code>目录</module_name></li>
<li>vertx uninstall <module_name> 与上面的命令相反</module_name></li>
</ul>
<p>关于Vert.x模块方面的东西,暂时先讲这么多.后期我会介绍几个Vert.x社区里特别流行的模块.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.streamis.me/2013/10/24/vert-dot-xmo-kuai-shen-ru/" data-id="cidzpu8bu000l614524nyp6gu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vert-dot-xmo-kuai-de-gai-nian" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/10/03/vert-dot-xmo-kuai-de-gai-nian/" class="article-date">
  <time datetime="2013-10-02T23:47:00.000Z" itemprop="datePublished">2013-10-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vert-x/">Vert.x</a>►<a class="article-category-link" href="/categories/Vert-x/Asynchronize-programming/">Asynchronize programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/03/vert-dot-xmo-kuai-de-gai-nian/">Vert.x模块的基本概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面在介绍里就已经提到Vert.x是一个微内核,可插拔的设计架构.对外只提供一些标准的API,通过Vert.x的<br>Platform来加载其他的Verticle,以及相关的模块.这种低耦合的设计可以方便将你的模块随意抽象,也可以注册发布到<br>公网上模块仓库提供给其他的开发者使用.</p>
<h2 id="什么Vert-x的模块">什么Vert.x的模块</h2><p>所谓Vert.x模块就是将你常用的,或者规划好verticle代码打包起来,这里的打包起来是打包成vert.x模块指定的目录格式.这样的包格式<br>为vert.x模块,一般用mod来表示.创建一个vert.x模块有哪些好处呢.</p>
<ul>
<li>classpath被vert.x环境自动装载.你不需要手动的设置其classpath.</li>
<li>所有的模块依赖都打包单个文件里,比如zip.</li>
<li>vert.x模块支持Maven仓库,这样你可以从Maven仓库里获取你的模块.</li>
<li>模块可以发布到vert.x的模块注册中心里提供给其他人使用.完善的生态圈</li>
<li>vert.x容器可以自动的下载并安装这些模块.(支持从maven仓库里或者远程二进制文件)</li>
</ul>
<p>基于以上的意见,强烈推荐将你应用包装成vert.x模块,而不是简单的verticles应用.(通过vertx run运行)</p>
<h2 id="模块结构">模块结构</h2><p>一个vert.x 模块就是一个zip文件,里面包含一些必须的文件(.class 文件, java文件 或者对应的语言脚本文件, lib目录下的jar资源,以及其他资源文件).<br>这点特别类似Jar文件结构.但是没有将vert.x做成与Jar文件结构一样的主要原因就是因为,Vert.x是一个多语言的异步开发框架.设想你的项目如果完全使用<br>Ruby或者Python脚本来运行,你又何必打包成Jar,这么奇怪的格式呢.</p>
<h3 id="模块描述文件_mod-json">模块描述文件 mod.json</h3><p>与主流的容器差不多比如Node.js,都是通过一个json文件来描述项目配置.<br>所有的vert.x模块都必须包含一个mod.json文件在模块的根目录下面.注意,这并不是标准的JS文件,注释只支持C形式的单行注释.<br>下面来看看mod.json包含哪些字段.</p>
<ul>
<li>main<br>main如同你所理解的一样,程序的入口,这里指定一个模块启动的时候运行的类或者脚本文件.给一些简单的例子.</li>
</ul>
<p><code>&quot;main&quot;: &quot;org.mycompany.mymod.MyMain&quot;</code> Java Class完整类名.</p>
<p><code>&quot;main&quot;: &quot;app.js&quot;</code> 指定一个JS文件</p>
<p><code>&quot;main&quot;: &quot;somedir/starter.rb&quot;</code> 指定一个ruby文件</p>
<p>默认Vert.x支持的语言有JS Java Groovy Ruby Python.这些都配置在vert.x home目录里的conf下,你会发现里面<br>有以个lang.properties文件,如果要支持其他语言比如Clojure.必须先添加.</p>
<ul>
<li><p>worker<br>如果模块被定义为worker,那就必须设置这个字段为true.默认是false.<br>这里再提醒一下Worker与非Worker的区别. Worker的运行是用的阻塞方式,所有的请求都会按顺序,一个一个的被执行.<br>标准的verticles则是用的事件线程.非阻塞方式.<br><code>&quot;worker&quot;:true</code></p>
</li>
<li><p>multi-threaded<br>因为worker默认一次只有一线程在跑,如果你恰好是一个可以支持多并发的应用,比如JDBC,其底层本身是支持连接池的方式来连接数据库.<br>这个时候你可以设置该worker为多线程应用,开启这个功能要非常小心,设置worker instances数目最好与线程池大小一致.</p>
</li>
<li><p>includes<br>一个模块可以在包含其他模块,这里的包含意味着被包含的模块的classloaders指向了此模块.这样被包含模块的资源文件以及class文件可以从包含模块访问.<br>类似于Java的包导入.<br><code>includes</code>内容可以用逗号隔开<br><code>&quot;includes&quot;: &quot;io.vertx~some-module~1.1,org.aardvarks~foo-mod~3.21-beta1&quot;</code></p>
</li>
<li><p>preserve-cwd<br>默认模块读取资源文件都是从模块的根目录读取.举个栗子.<br>你的模块有如下目录结构<br>  /mod.json<br>  /server.js<br>  /web/index.html<br>按要求返回目标html内容.下面是server.js的内容</p>
<figure class="highlight javascript"><figcaption><span>simple http server - server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertx = <span class="built_in">require</span>(<span class="string">'vertx'</span>)</span><br><span class="line">vertx.createHttpServer().requestHandler(<span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">   req.response.sendFile(<span class="string">'./web/index.html'</span>); <span class="comment">// Always serve the index page</span></span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">'foo.com'</span>)</span><br></pre></td></tr></table></figure>
<p>默认的<code>.</code>可以访问到模块的根目录,但是如果你希望访问的文件不在模块根目录下,则可以设置<code>preserver-cwd</code>为<code>false</code>.<br>默认是<code>false</code></p>
</li>
<li><p>auto-redeploy<br>设置此参数为<code>true</code>的话,Vert.x将自动重新部署模块,如果发现模块资源文件发生变动.<br>典型的场景就是Web项目,改个CSS, JS文件是很平常的事情.当然静态文件不用Vert.x也可以实现.如果是java class文件,就比较麻烦了.<br>Vert.x模块重部署会自动监视相关的classpath路径是否发生改变,如果发生改变则自动重新部署.</p>
</li>
</ul>
<p>此外它对IDE以及项目编译工具支持都很好.<strong>需要安装相关的构建工具插件</strong><br>你可以通过gradle或者maven生成对应的vert.x项目目录.<br><code>./gradlew runModEclipse</code> Eclipse下使用gradle<br><code>./gradlew runModIDEA</code> IDEA下使用gradle</p>
<p><code>mvn vertx:runModEclipse</code> Eclipse下使用maven<br><code>mvn vertx:runModIDEA</code> IDEA下使用Maven</p>
<p>具体的可以查看官方介绍<a href="http://vertx.io/dev_guide.html#auto-redeploy" target="_blank" rel="external">auto-redeploy</a></p>
<ul>
<li><p>resident<br>通常Vert.x模块对其他模块的引用都是在内存里,即加载模块到内存里,当此模块不再被引用的时候从内存里则卸载此模块.但是对于特别的模块,比如相关语言实现的模块,频繁的加载卸载会导致<br>Java堆溢出.(每一次特定语言实现都会被加载一次然后卸载一次,如果存在20个JS文件,那么就是20次,Java堆里可能有20份Rhino的class文件).resident如其名,常驻的意思,即加载完这个模块<br>后,一直不释放,直到Vert.x实例被终止.一般存在于语言实现上面才重用这个字段,默认是<code>false</code>.当然,我的项目里依赖Guice,等其他的Java共用包,我也会把那个模块设置成<code>&quot;resident&quot;:true</code></p>
</li>
<li><p>system<br>默认模块的安装路径是在模块调用目录下的<code>mods</code>文件夹下,当然你可以设置<code>VERTX_MODS</code>环境变量来改变其默认设置.但是一些模块,比如语言实现模块,需要被其他模块共享,所以为了避免多次的下载<br>加载到不同的mods下,你可以配置<code>&quot;system&quot;&quot;:true</code>.这样就会在VERTX_HOME下的<code>sys-mod</code>存在该模块.(此目录下的模块,被所有的Vert.x应用共享),默认是<code>false</code>.</p>
</li>
<li><p>其他的字段<br>其他的字段眼睛一瞄你就应该知道什么意思,我就不说了.比如<code>description</code>, <code>licenses</code>, <code>author</code>, <code>homepage</code>等.</p>
</li>
</ul>
<h3 id="其他">其他</h3><p>关于Vert.x 模块的类加载以及资源包含,嵌套模块等部分,下一篇将讲解.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.streamis.me/2013/10/03/vert-dot-xmo-kuai-de-gai-nian/" data-id="cidzpu8bx000p61459sz5cx7g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Emacs/">Emacs</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Storm/">Storm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vert-x/">Vert.x</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vert-x/Asynchronize-programming/">Asynchronize programming</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vert-x/micro-service/">micro-service</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/vert-x源码分析/">vert.x源码分析</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/05/26/vertx-rpckuang-jia/">Vertx-rpc框架</a>
          </li>
        
          <li>
            <a href="/2014/10/06/vert-dot-x3-update/">Vert.x3 Update</a>
          </li>
        
          <li>
            <a href="/2014/05/06/vert-dot-xyu-lao-xiang-mu-jie-he/">Vert.x与老项目结合</a>
          </li>
        
          <li>
            <a href="/2014/05/04/vert-dot-xli-yi-bu-chu-li-di-san-fang-fu-wu/">Vert.x里异步处理第三方服务</a>
          </li>
        
          <li>
            <a href="/2014/05/02/os-x-xia-she-zhi-emacs-shellde-ls-color/">OS X 下设置Emacs Shell-mode 输出颜色</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Stream Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>